// 交个神仙朋友 PWA Service Worker
const CACHE_NAME = 'divine-friend-pwa-v1.0.0'
const STATIC_CACHE_URLS = [
  '/',
  '/manifest.json',
  '/static/css/main.css',
  '/static/js/main.js',
  'https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@300;400;500;600;700&display=swap'
]

// 安装事件 - 缓存静态资源
self.addEventListener('install', (event) => {
  console.log('🚀 Service Worker 正在安装...')
  
  event.waitUntil(
    caches.open(CACHE_NAME)
      .then((cache) => {
        console.log('📦 正在缓存静态资源...')
        return cache.addAll(STATIC_CACHE_URLS)
      })
      .then(() => {
        console.log('✅ 静态资源缓存完成')
        // 强制激活新的 Service Worker
        return self.skipWaiting()
      })
      .catch((error) => {
        console.error('❌ 缓存失败:', error)
      })
  )
})

// 激活事件 - 清理旧缓存
self.addEventListener('activate', (event) => {
  console.log('🔄 Service Worker 正在激活...')
  
  event.waitUntil(
    caches.keys()
      .then((cacheNames) => {
        return Promise.all(
          cacheNames.map((cacheName) => {
            if (cacheName !== CACHE_NAME) {
              console.log('🗑️ 删除旧缓存:', cacheName)
              return caches.delete(cacheName)
            }
          })
        )
      })
      .then(() => {
        console.log('✅ Service Worker 激活完成')
        // 立即控制所有页面
        return self.clients.claim()
      })
  )
})

// 拦截网络请求
self.addEventListener('fetch', (event) => {
  // 只处理 GET 请求
  if (event.request.method !== 'GET') {
    return
  }

  // 跳过非 HTTP(S) 请求
  if (!event.request.url.startsWith('http')) {
    return
  }

  event.respondWith(
    caches.match(event.request)
      .then((cachedResponse) => {
        // 如果缓存中有响应，直接返回
        if (cachedResponse) {
          console.log('📦 从缓存返回:', event.request.url)
          return cachedResponse
        }

        // 网络请求
        return fetch(event.request)
          .then((response) => {
            // 检查响应是否有效
            if (!response || response.status !== 200 || response.type !== 'basic') {
              return response
            }

            // 克隆响应用于缓存
            const responseToCache = response.clone()

            // 缓存新的响应
            caches.open(CACHE_NAME)
              .then((cache) => {
                // 只缓存特定类型的资源
                if (shouldCache(event.request.url)) {
                  console.log('💾 缓存新资源:', event.request.url)
                  cache.put(event.request, responseToCache)
                }
              })

            return response
          })
          .catch((error) => {
            console.log('🌐 网络请求失败:', event.request.url, error)
            
            // 如果是导航请求且失败，返回离线页面
            if (event.request.mode === 'navigate') {
              return caches.match('/')
            }
            
            throw error
          })
      })
  )
})

// 判断是否应该缓存该资源
function shouldCache(url) {
  // 缓存策略：缓存静态资源和API响应
  const cachePatterns = [
    /\.(js|css|png|jpg|jpeg|gif|svg|woff|woff2|ttf|eot)$/,
    /\/api\//,
    /fonts\.googleapis\.com/
  ]
  
  return cachePatterns.some(pattern => pattern.test(url))
}

// 后台同步事件（如果支持）
if ('sync' in self.registration) {
  self.addEventListener('sync', (event) => {
    console.log('🔄 后台同步事件:', event.tag)
    
    if (event.tag === 'blessing-sync') {
      event.waitUntil(syncBlessings())
    }
  })
}

// 推送通知事件
self.addEventListener('push', (event) => {
  console.log('📱 收到推送通知:', event)
  
  if (event.data) {
    const data = event.data.json()
    const options = {
      body: data.body || '您有新的神仙朋友消息',
      icon: '/icon-192x192.png',
      badge: '/icon-72x72.png',
      tag: data.tag || 'divine-friend-notification',
      data: data,
      actions: [
        {
          action: 'open',
          title: '查看',
          icon: '/icon-72x72.png'
        },
        {
          action: 'close',
          title: '关闭'
        }
      ],
      requireInteraction: true,
      silent: false
    }

    event.waitUntil(
      self.registration.showNotification(data.title || '神仙朋友', options)
    )
  }
})

// 通知点击事件
self.addEventListener('notificationclick', (event) => {
  console.log('🔔 通知被点击:', event)
  
  event.notification.close()
  
  if (event.action === 'open' || !event.action) {
    event.waitUntil(
      clients.matchAll({ type: 'window' })
        .then((clientList) => {
          // 如果已有窗口打开，聚焦到该窗口
          for (const client of clientList) {
            if (client.url === self.location.origin && 'focus' in client) {
              return client.focus()
            }
          }
          
          // 否则打开新窗口
          if (clients.openWindow) {
            return clients.openWindow('/')
          }
        })
    )
  }
})

// 同步祝福数据（示例函数）
async function syncBlessings() {
  try {
    console.log('🙏 正在同步祝福数据...')
    
    // 这里可以实现实际的数据同步逻辑
    // 例如：从 IndexedDB 获取离线数据并上传到服务器
    
    console.log('✅ 祝福数据同步完成')
  } catch (error) {
    console.error('❌ 祝福数据同步失败:', error)
    throw error
  }
}

// 消息处理（与主线程通信）
self.addEventListener('message', (event) => {
  console.log('📨 收到消息:', event.data)
  
  if (event.data && event.data.type === 'SKIP_WAITING') {
    self.skipWaiting()
  }
  
  if (event.data && event.data.type === 'GET_VERSION') {
    event.ports[0].postMessage({ version: CACHE_NAME })
  }
})

console.log('🧘‍♂️ 神仙朋友 Service Worker 已加载') 